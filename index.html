<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kábelárok kalkulátor – MSZ 13207:2020 szerint</title>
  <style>
    :root { --gap: 12px; --radius: 12px; }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;line-height:1.35;margin:0;background:#0b1220;color:#e7ecf5}
    header{padding:24px 16px;text-align:center;background:#0e1630;border-bottom:1px solid #26324d}
    main{max-width:1100px;margin:0 auto;padding:20px;display:grid;gap:20px}
    .card{background:#121a34;border:1px solid #26324d;border-radius:var(--radius);padding:16px}
    h1{font-size:clamp(1.2rem,2.5vw,1.6rem);margin:0 0 6px}
    h2{font-size:1.05rem;margin:0 0 10px}
    small,.muted{color:#9fb0cf}
    .row{display:flex;gap:var(--gap);flex-wrap:wrap;align-items:flex-end}
    .row > *{flex:1 1 220px}
    input,select,button{width:100%;box-sizing:border-box;border-radius:10px;border:1px solid #39507d;background:#0b142c;color:#e7ecf5;padding:10px 12px}
    input[type=number]{appearance:textfield}
    button{cursor:pointer;background:#2a6df3;border-color:#2a6df3}
    button.secondary{background:#182445;border-color:#39507d}
    button:disabled{opacity:.6;cursor:not-allowed}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid #26324d;text-align:left}
    tr:hover td{background:#0f1a34}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #39507d;background:#0b142c;color:#cdd9f0;font-size:.85rem}
    .grid{display:grid;gap:var(--gap)}
    .two{grid-template-columns:repeat(2,minmax(0,1fr))}
    .result{font-size:1.25rem}
    .ok{color:#86efac}.warn{color:#fbbf24}.bad{color:#f87171}
    footer{opacity:.85;padding:10px 16px;text-align:center}
    .inline-help{font-size:.9rem;color:#9fb0cf}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid #39507d;border-radius:999px;background:#0b142c}
    .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .right{text-align:right}
    .svg-wrap{background:#0b142c;border:1px dashed #39507d;border-radius:10px;padding:10px}
  </style>
</head>
<body>
  <header>
    <h1>Kábelárok kalkulátor – MSZ 13207:2020</h1>
    <small>Másold be a kábeleket, válaszd ki a fektetést, és megkapod a szabvány szerinti minimális méreteket.</small>
  </header>

  <main>
    <!-- 1) BEÁLLÍTÁSOK -->
    <section class="card">
      <h2>1) Általános beállítások</h2>
      <div class="row">
        <div>
          <label>Terület típusa
            <select id="terrain">
              <option value="regulated">Szabályozott terep – tipikusan 0,6…0,8 m fektetési mélység</option>
              <option value="unregulated">Szabályozatlan terep – min. 1,0 m fektetési mélység</option>
            </select>
          </label>
        </div>
        <div>
          <label>Választott fektetési mélység (m)
            <input id="depth" type="number" step="0.1" min="0.3" value="0.7">
          </label>
          <div class="inline-help">Ajánlott kiindulás: 0,7 m (szabályozott terepen).</div>
        </div>
        <div>
          <label>Elrendezés a kábelárokban
            <select id="layout">
              <option value="single">Egy síkban (sorba rendezve)</option>
              <option value="trefoil">Három egyerű kábel érintő háromszögben (trefoil)</option>
              <option value="multirow">Több réteg (egymás felett)</option>
            </select>
          </label>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Oldaltávolság (m)
            <input id="sideClear" type="number" step="0.01" value="0.10" min="0.10">
          </label>
          <div class="inline-help">Min. 0,10 m mindkét oldalon.</div>
        </div>
        <div>
          <label>Kábelek közötti távolság (m)
            <input id="spacing" type="number" step="0.01" value="0.07" min="0.05">
          </label>
          <div class="inline-help">Alap: 0,07 m (védőcsövek közt min. 0,05 m).</div>
        </div>
        <div>
          <label>Ágyazóréteg alul/felül (m)
            <input id="bedding" type="number" step="0.01" value="0.05" min="0.00">
          </label>
          <div class="inline-help">I–II. talajban nem feltétlen kötelező; máskor jellemzően min. 0,05 m.</div>
        </div>
      </div>
    </section>

    <!-- 2) KÁBEL LISTA -->
    <section class="card">
      <h2>2) Kábelek felvétele</h2>
      <div class="row">
        <div>
          <label>Kábel külső átmérő (mm)
            <input id="diameter" type="number" step="1" min="1" value="40">
          </label>
        </div>
        <div>
          <label>Darabszám
            <input id="count" type="number" step="1" min="1" value="3">
          </label>
        </div>
        <div>
          <label>Védőcsőben?
            <select id="inDuct">
              <option value="no">Nem</option>
              <option value="yes">Igen (védőcső)</option>
            </select>
          </label>
        </div>
        <div>
          <label>Megjegyzés (opcionális)
            <input id="note" type="text" placeholder="pl. 3×1C 240 mm² trefoil csoport">
          </label>
        </div>
        <div><button id="addCable">Felvétel</button></div>
      </div>

      <table id="cableTable">
        <thead>
          <tr>
            <th>#</th><th>Átmérő (mm)</th><th>Darab</th><th>Védőcső</th><th>Megjegyzés</th><th></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div class="flex">
        <span class="chip">Min. árokszélesség: <span class="pill">400 mm</span></span>
        <span class="chip">Min. kábel-köz: <span class="pill">70 mm</span> (<span class="pill">50 mm</span> védőcsövek közt)</span>
        <span class="chip">Oldaltávolság: <span class="pill">100 mm</span> / oldal</span>
      </div>
    </section>

    <!-- 3) EREDMÉNY + RAJZ + EXPORT -->
    <section class="card">
      <h2>3) Eredmények & sematikus rajz</h2>
      <div class="grid two">
        <div class="result">Számított <strong>kábelárok-szélesség</strong>: <span id="widthOut" class="pill">–</span></div>
        <div class="result">Becsült <strong>kábelárok-mélység</strong>: <span id="depthOut" class="pill">–</span></div>
      </div>
      <div class="grid">
        <div><span class="pill">Jelzőszalag: min. 0,3 m-rel a legfelső kábel felett</span> <span id="tapeLevel" class="muted"></span></div>
        <div class="inline-help">A rajz keresztmetszet: <strong>felül</strong> a felszín, <strong>alul</strong> a kábelek az ágyazóban.</div>
      </div>

      <div class="svg-wrap" style="margin-top:10px">
        <svg id="schematic" width="100%" height="380" viewBox="0 0 840 380" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Kábelárok sematikus rajz">
          <!-- Dinamikus rajz -->
        </svg>
      </div>

      <div class="row" style="margin-top:10px">
        <div><button class="secondary" id="exportBtn">Eredmény letöltése (TXT)</button></div>
        <div><button class="secondary" id="exportDxfBtn">Rajz exportálása (DXF)</button></div>
      </div>
    </section>

    <section class="card">
      <h2>Hivatkozás</h2>
      <small>MSZ 13207:2020 – geometriai minimumok: kábel-köz ≥ 0,07 m, oldaltávolság ≥ 0,10 m, min. árokszélesség 0,40 m; trefoil és többrétegű fektetés megengedett; jelzőszalag ≥ 0,3 m-rel feljebb; tipikus mélység szabályozott terepen 0,6–0,8 m.</small>
    </section>
  </main>

  <footer class="muted">Készült a SolServices részére • DXF-exporttal</footer>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const state = { items: [] };

    const tableBody = $("#cableTable tbody");
    const terrain = $("#terrain");
    const depthInput = $("#depth");
    const layoutSel = $("#layout");
    const sideClear = $("#sideClear");
    const spacing = $("#spacing");
    const bedding = $("#bedding");
    const widthOut = $("#widthOut");
    const depthOut = $("#depthOut");
    const tapeLevel = $("#tapeLevel");
    const svg = $("#schematic");

    function mm(v){ return Number(v) || 0 }
    function round(v,dec=2){ const p=Math.pow(10,dec); return Math.round(v*p)/p }
    function toMeters(mmVal){ return (mmVal/1000) }
    function safeParse(v,def=0){ const n=Number(v); return isFinite(n)?n:def }

    function renderTable(){
      tableBody.innerHTML = "";
      state.items.forEach((it,idx)=>{
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${idx+1}</td>
          <td>${it.diam} mm</td>
          <td>${it.count}</td>
          <td>${it.inDuct ? "Igen" : "Nem"}</td>
          <td>${it.note||""}</td>
          <td class="right"><button class="secondary" data-remove="${idx}">Törlés</button></td>
        `;
        tableBody.appendChild(tr);
      });
      tableBody.querySelectorAll("button[data-remove]").forEach(btn=>{
        btn.addEventListener("click", e=>{
          const i = Number(e.target.getAttribute("data-remove"));
          state.items.splice(i,1);
          renderTable();
          compute();
        })
      })
    }

    function addCable(){
      const diam = mm($("#diameter").value);
      const count = Math.max(1, Math.floor(safeParse($("#count").value,1)));
      const inDuct = $("#inDuct").value === "yes";
      const note = $("#note").value.trim();

      if(diam<=0){ alert("Adj meg érvényes kábel-átmérőt (mm)!"); return; }
      state.items.push({diam, count, inDuct, note});
      $("#note").value="";
      renderTable();
      compute();
    }
    $("#addCable").addEventListener("click", addCable);

    function compute(){
      const side = Math.max(0.10, safeParse(sideClear.value, 0.10));           // m
      const baseSpacing = Math.max(0.05, safeParse(spacing.value, 0.07));      // m
      const bed = Math.max(0, safeParse(bedding.value, 0.05));                 // m
      const depthSel = Math.max(0.3, safeParse(depthInput.value, 0.7));        // m
      const layout = layoutSel.value;

      const terr = terrain.value;
      const minDepth = terr === "regulated" ? 0.6 : 1.0;
      const usedDepth = Math.max(depthSel, minDepth);                           // kábel teteje a terepszint alatt

      // elemek (védőcső egyszerűsített +10 mm)
      let elements = [];
      state.items.forEach(it=>{
        const effDiam = it.inDuct ? (it.diam + 10) : it.diam;
        for(let i=0;i<it.count;i++){ elements.push({d_mm: effDiam}); }
      });

      let rows = [];
      const sToM = (arr)=> arr.reduce((sum,e)=>sum + toMeters(e.d_mm),0);

      if(layout==="trefoil"){
        // 3-as csoportok; csoport vízszintes befoglaló: 2*d
        elements.sort((a,b)=>b.d_mm-a.d_mm);
        let groups=[];
        for(let i=0;i<elements.length;i+=3){
          const g = elements.slice(i,i+3);
          if(g.length===0) break;
          const dmm = Math.max(...g.map(x=>x.d_mm)); // csoport d
          groups.push({d_m: toMeters(dmm)});
        }
        const width = groups.length ? groups.reduce((s,g)=>s + 2*g.d_m, 0) + (groups.length-1)*baseSpacing : 0;
        rows = [{type:"trefoil", width_m: width, groups}];
      } else if(layout==="multirow"){
        elements.sort((a,b)=>b.d_mm-a.d_mm);
        const half = Math.ceil(elements.length/2);
        const rowA = elements.slice(0, half);
        const rowB = elements.slice(half);
        const wA = (rowA.length? sToM(rowA) + (rowA.length-1)*baseSpacing : 0);
        const wB = (rowB.length? sToM(rowB) + (rowB.length-1)*baseSpacing : 0);
        rows = [
          {type:"line", width_m:wA, items: rowA.map(e=>({d_m: toMeters(e.d_mm)}))},
          {type:"line", width_m:wB, items: rowB.map(e=>({d_m: toMeters(e.d_mm)}))}
        ];
      } else {
        const w = (elements.length? sToM(elements) + (elements.length-1)*baseSpacing : 0);
        rows = [{type:"line", width_m: w, items: elements.map(e=>({d_m: toMeters(e.d_mm)}))}];
      }

      const innerWidth = rows.reduce((m,r)=>Math.max(m, r.width_m), 0);
      const trenchWidth = Math.max(0.4, innerWidth + 2*side);

      const topOfCable = usedDepth;               // kábel teteje
      const trenchDepth = topOfCable + bed;       // becsült teljes árok
      const tape = topOfCable + 0.30;

      widthOut.textContent = `${round(trenchWidth, 3)} m (min)`;
      depthOut.textContent = `${round(trenchDepth, 3)} m (becsült árok-mélység)`;
      tapeLevel.textContent = `– javasolt elhelyezési szint: ${round(tape,2)} m a terepszint alatt`;
      widthOut.className = "pill " + (trenchWidth >= 0.4 && side >= 0.10 ? "ok":"bad");
      if(terr==="regulated" && (usedDepth<0.6 || usedDepth>0.8)){
        depthOut.className = "pill warn";
      }else if(terr==="unregulated" && usedDepth<1.0){
        depthOut.className = "pill bad";
      }else{
        depthOut.className = "pill ok";
      }

      drawSVG({rows, trenchWidth, trenchDepth, side, baseSpacing, bed, usedDepth, topOfCable});
      state._geom = {rows, trenchWidth, trenchDepth, side, baseSpacing, bed, usedDepth, topOfCable};
    }

    // ===== SVG RAJZ =====
    function drawSVG(g){
      const Wpx = 840, Hpx = 380;
      svg.setAttribute("viewBox", `0 0 ${Wpx} ${Hpx}`);
      while(svg.firstChild) svg.removeChild(svg.firstChild);

      const margin = 50;
      const pxPerM_X = (Wpx - 2*margin) / Math.max(0.8, g.trenchWidth);
      const pxPerM_Y = (Hpx - 2*margin) / Math.max(0.8, g.trenchDepth);

      // FELSZÍN felül! – függőleges tengely: y nő lefelé.
      const ox = (Wpx - g.trenchWidth * pxPerM_X)/2;      // bal belső
      const topY = margin;                                 // felszín (y=margin)
      const trenchHpx = g.trenchDepth * pxPerM_Y;
      const trenchWpx = g.trenchWidth * pxPerM_X;

      // Árok téglalap (felül a felszín, alul az alj)
      svg.appendChild(rectEl(ox, topY, trenchWpx, trenchHpx, "#334a7a", "#99b3ff12"));

      // „Felszín” felirat
      const tSurf = textEl(ox + trenchWpx/2, topY - 8, "FELSZÍN");
      tSurf.setAttribute("text-anchor","middle");
      svg.appendChild(tSurf);

      // Alsó ágyazóréteg jelölése (a fenék felett)
      if(g.bed>0){
        const yBed = topY + trenchHpx - g.bed*pxPerM_Y;
        svg.appendChild(lineEl(ox, yBed, ox+trenchWpx, yBed, "#5fa8ff99", 2));
        const t = textEl(ox + trenchWpx - 6, yBed - 4, `Ágyazóréteg (${g.bed.toFixed(2)} m)`);
        t.setAttribute("text-anchor","end");
        svg.appendChild(t);
      }

      // Kábelek az alján: bázis y (fenéktől felfelé kis vizuális ráhagyás)
      const baseY_m = g.bed + 0.02;
      let rowYs = (g.rows.length===1) ? [baseY_m] : [baseY_m, baseY_m + 0.20];

      // vízszintes skála, bal falhoz viszonyítva
      const startX_px = (m)=> ox + m*pxPerM_X;
      const yFromBottom_px = (m)=> topY + trenchHpx - m*pxPerM_Y;

      g.rows.forEach((row, rIdx)=>{
        if(row.type==="trefoil"){
          // csoportok egymás mellett; csoport szélesség = 2*d
          const totalW = row.groups.reduce((s,gp)=>s + 2*gp.d_m, 0) + ((row.groups.length-1)*g.baseSpacing);
          let x0_m = (g.trenchWidth - totalW)/2;

          row.groups.forEach((gp, i)=>{
            const d = gp.d_m, r = d/2;
            // alsó két kör: középpontok egymástól d-re, y = base + r
            const yBottom_m = rowYs[rIdx] + r;
            const cxLeft_m  = x0_m + r;
            const cxRight_m = x0_m + r + d;
            // felső kör: középen, d*sqrt(3)/2-vel feljebb
            const cxTop_m = x0_m + d;
            const yTop_m = yBottom_m + d*Math.sqrt(3)/2;

            // rajz (y lefelé nő, ezért yFromBottom_px)
            [ [cxLeft_m,yBottom_m], [cxRight_m,yBottom_m], [cxTop_m,yTop_m] ]
              .forEach(([cx,cy])=>{
                svg.appendChild(circleEl(startX_px(cx), yFromBottom_px(cy), r*pxPerM_X, "#2a5fff", "#2a5fff55"));
              });

            x0_m += 2*d + g.baseSpacing;
          });
        } else {
          // egysoros sor
          const arr = row.items;
          const rowW = arr.length ? arr.reduce((s,it)=>s+it.d_m,0) + (arr.length-1)*g.baseSpacing : 0;
          let x_m = (g.trenchWidth - rowW)/2;
          const maxd = arr.length? Math.max(...arr.map(i=>i.d_m)) : 0;
          const cy_m = rowYs[rIdx] + maxd/2;

          arr.forEach((it, i)=>{
            const r = it.d_m/2;
            svg.appendChild(circleEl(startX_px(x_m + r), yFromBottom_px(cy_m), r*pxPerM_X, "#2a5fff", "#2a5fff55"));
            x_m += it.d_m + (i<arr.length-1 ? g.baseSpacing : 0);
          });
        }
      });

      // méretvonalak
      const wY = topY + trenchHpx + 26;  // szélességjel alul
      svg.appendChild(dimLine(ox, wY, ox+trenchWpx, wY, `${round(g.trenchWidth,2)} m`));
      const dX = ox - 34;                // mélység balra
      svg.appendChild(dimVLine(dX, topY, topY+trenchHpx, `${round(g.trenchDepth,2)} m`));
      // oldaltávolságok
      const ySide = topY + trenchHpx + 8;
      svg.appendChild(dimLine(ox, ySide, ox + g.side*pxPerM_X, ySide, `${round(g.side,2)} m oldal`));
      svg.appendChild(dimLine(ox+trenchWpx - g.side*pxPerM_X, ySide, ox+trenchWpx, ySide, `${round(g.side,2)} m oldal`));
    }

    // ===== SVG primitivek =====
    function rectEl(x,y,w,h,stroke,fill){
      const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
      r.setAttribute("x", x); r.setAttribute("y", y); r.setAttribute("width", w); r.setAttribute("height", h);
      r.setAttribute("fill", fill||"none"); r.setAttribute("stroke", stroke||"#999"); r.setAttribute("stroke-width", 2);
      return r;
    }
    function lineEl(x1,y1,x2,y2,stroke="#9fb0cf",sw=2){
      const l = document.createElementNS("http://www.w3.org/2000/svg","line");
      l.setAttribute("x1",x1); l.setAttribute("y1",y1); l.setAttribute("x2",x2); l.setAttribute("y2",y2);
      l.setAttribute("stroke",stroke); l.setAttribute("stroke-width",sw); return l;
    }
    function circleEl(cx,cy,r,stroke,fill){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", r);
      c.setAttribute("fill", fill||"none"); c.setAttribute("stroke", stroke||"#2a5fff"); c.setAttribute("stroke-width", 2);
      return c;
    }
    function textEl(x,y,txt){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.textContent = txt; t.setAttribute("x",x); t.setAttribute("y",y);
      t.setAttribute("fill","#cfe1ff"); t.setAttribute("font-size","12"); return t;
    }
    function dimLine(x1,y1,x2,y2,label){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.appendChild(lineEl(x1,y1,x2,y2));
      g.appendChild(arrow(x1,y1,true)); g.appendChild(arrow(x2,y2,false));
      const t = textEl((x1+x2)/2, y2-6, label); t.setAttribute("text-anchor","middle"); g.appendChild(t); return g;
    }
    function dimVLine(x1,y1,y2,label){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.appendChild(lineEl(x1,y1,x1,y2));
      g.appendChild(varrow(x1,y1,true)); g.appendChild(varrow(x1,y2,false));
      const t = textEl(x1-6, (y1+y2)/2, label); t.setAttribute("text-anchor","end"); g.appendChild(t); return g;
    }
    function arrow(x,y,left){
      const p = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      const s = left? `${x+8},${y-6} ${x},${y} ${x+8},${y+6}` : `${x-8},${y-6} ${x},${y} ${x-8},${y+6}`;
      p.setAttribute("points", s); p.setAttribute("fill","none"); p.setAttribute("stroke","#9fb0cf"); p.setAttribute("stroke-width","2"); return p;
    }
    function varrow(x,y,up){
      const p = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      const s = up? `${x-6},${y+8} ${x},${y} ${x+6},${y+8}` : `${x-6},${y-8} ${x},${y} ${x+6},${y-8}`;
      p.setAttribute("points", s); p.setAttribute("fill","none"); p.setAttribute("stroke","#9fb0cf"); p.setAttribute("stroke-width","2"); return p;
    }

    // ===== TXT EXPORT =====
    $("#exportBtn").addEventListener("click", ()=>{
      const lines = [];
      lines.push("Kábelárok kalkuláció – MSZ 13207:2020");
      lines.push("");
      lines.push(`Terep: ${terrain.value==="regulated"?"Szabályozott":"Szabályozatlan"}`);
      lines.push(`Választott fektetési mélység (kábel teteje): ${round(Math.max(0.3, Number(depthInput.value)||0.7),2)} m`);
      lines.push(`Elrendezés: ${layoutSel.options[layoutSel.selectedIndex].text}`);
      lines.push(`Oldaltávolság: ≥ ${round(Math.max(0.10, Number(sideClear.value)||0.10),2)} m (oldalanként)`);
      lines.push(`Kábel/köteg közti távolság: ≥ ${round(Math.max(0.05, Number(spacing.value)||0.07),2)} m`);
      lines.push(`Ágyazóréteg (alul/felül): ${round(Math.max(0, Number(bedding.value)||0.05),2)} m`);
      lines.push("");
      state.items.forEach((it,i)=>{
        lines.push(`#${i+1} – d=${it.diam} mm , védőcső: ${it.inDuct?"igen":"nem"}${it.note?(" , megjegyzés: "+it.note):""}`);
      });
      lines.push("");
      lines.push(`Számított árokszélesség (min): ${$("#widthOut").textContent}`);
      lines.push(`Becsült árok-mélység: ${$("#depthOut").textContent}`);
      lines.push(`Jelzőszalag szint (min): ${$("#tapeLevel").textContent.replace("– ","")}`);
      const blob = new Blob([lines.join("\n")], {type:"text/plain"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "kabelarok_kalkulacio.txt";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    });

    // ===== DXF EXPORT (R12, méter) =====
    function dxfHeader(){
      return [
        "0","SECTION","2","HEADER",
        "9","$INSUNITS","70","6",   // meters
        "0","ENDSEC",
        "0","SECTION","2","ENTITIES"
      ].join("\n");
    }
    function dxfFooter(){ return "0\nENDSEC\n0\nEOF\n"; }
    function dxfLine(x1,y1,x2,y2,layer="0"){
      return ["0","LINE","8",layer,"10",x1,"20",y1,"30",0,"11",x2,"21",y2,"31",0].join("\n");
    }
    function dxfCircle(cx,cy,r,layer="0"){
      return ["0","CIRCLE","8",layer,"10",cx,"20",cy,"30",0,"40",r].join("\n");
    }
    function dxfText(x,y,h,txt,layer="0"){
      return ["0","TEXT","8",layer,"10",x,"20",y,"30",0,"40",h,"1",txt].join("\n");
    }

    function exportDXF(){
      const g = state._geom;
      if(!g){ alert("Előbb adj meg kábeleket és számolj!"); return; }

      let ents = [];
      ents.push(dxfHeader());
      const W = g.trenchWidth, D = g.trenchDepth;

      // Árok kontúr (origó bal-alsó)
      ents.push(dxfLine(0,0, W,0, "TRENCH"));
      ents.push(dxfLine(W,0, W,D, "TRENCH"));
      ents.push(dxfLine(W,D, 0,D, "TRENCH"));
      ents.push(dxfLine(0,D, 0,0, "TRENCH"));

      // Alsó ágyazóréteg vonala
      if(g.bed>0){ ents.push(dxfLine(0,g.bed, W,g.bed, "BED")); }

      // Kábelek (alul): az SVG-hez hasonlóan – trefoil pontos geometriával
      const baseY = g.bed + 0.02;
      let rowYs = (g.rows.length===1) ? [baseY] : [baseY, baseY + 0.20];

      g.rows.forEach((row, rIdx)=>{
        if(row.type==="trefoil"){
          const totalW = row.groups.reduce((s,gp)=>s + 2*gp.d_m, 0) + ((row.groups.length-1)*g.baseSpacing);
          let x = (W - totalW)/2;              // bal befoglaló
          row.groups.forEach((gp)=>{
            const d = gp.d_m, r = d/2;
            const yB = rowYs[rIdx] + r;
            const cxL = x + r;
            const cxR = x + r + d;
            const cxT = x + d;
            const yT  = yB + d*Math.sqrt(3)/2;

            [ [cxL,yB], [cxR,yB], [cxT,yT] ].forEach(([cx,cy])=>{
              ents.push(dxfCircle(cx, cy, r, "CABLE"));
            });
            x += 2*d + g.baseSpacing;
          });
        } else {
          const arr = row.items;
          const rowW = arr.length? arr.reduce((s,it)=>s+it.d_m,0) + (arr.length-1)*g.baseSpacing : 0;
          let x = (W - rowW)/2;
          const maxd = arr.length? Math.max(...arr.map(i=>i.d_m)) : 0;
          const cy = rowYs[rIdx] + maxd/2;
          arr.forEach((it, i)=>{
            ents.push(dxfCircle(x + it.d_m/2, cy, it.d_m/2, "CABLE"));
            x += it.d_m + (i<arr.length-1 ? g.baseSpacing : 0);
          });
        }
      });

      // Méretvonalak (egyszerű)
      ents.push(dxfLine(0,-0.10, W,-0.10, "DIM"));
      ents.push(dxfLine(0,-0.12, 0,-0.08, "DIM"));
      ents.push(dxfLine(W,-0.12, W,-0.08, "DIM"));
      ents.push(dxfText(W/2, -0.16, 0.05, `${round(W,2)} m`, "DIM"));
      ents.push(dxfLine(-0.10,0, -0.10,D, "DIM"));
      ents.push(dxfLine(-0.12,0, -0.08,0, "DIM"));
      ents.push(dxfLine(-0.12,D, -0.08,D, "DIM"));
      ents.push(dxfText(-0.14, D/2, 0.05, `${round(D,2)} m`, "DIM"));

      // Oldaltávolság jelzések
      ents.push(dxfLine(0,-0.30, g.side, -0.30, "DIM"));
      ents.push(dxfText(g.side/2, -0.34, 0.04, `${round(g.side,2)} m oldal`, "DIM"));
      ents.push(dxfLine(W-g.side, -0.30, W, -0.30, "DIM"));
      ents.push(dxfText(W-g.side/2, -0.34, 0.04, `${round(g.side,2)} m oldal`, "DIM"));

      // Jelzőszalag szint
      const tapeY = g.topOfCable + 0.30;
      ents.push(dxfLine(-0.20, tapeY, W+0.20, tapeY, "TAPE"));
      ents.push(dxfText(W+0.22, tapeY, 0.04, "jelzőszalag +0.30 m", "TAPE"));

      ents.push(dxfFooter());
      const blob = new Blob([ents.join("\n")], {type:"application/dxf"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "kabelarok_rajz.dxf";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }
    $("#exportDxfBtn").addEventListener("click", exportDXF);

    // reakciók
    [terrain, depthInput, layoutSel, sideClear, spacing, bedding].forEach(el=>{
      el.addEventListener("input", compute);
      el.addEventListener("change", compute);
    });

    // init
    function init(){ renderTable(); compute(); }
    init();
  </script>
</body>
</html>
