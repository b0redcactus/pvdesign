<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kábelárok kalkulátor – MSZ 13207:2020 szerint</title>
  <style>
    :root { --gap: 12px; --radius: 12px; }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;line-height:1.35;margin:0;background:#0b1220;color:#e7ecf5}
    header{padding:24px 16px;text-align:center;background:#0e1630;border-bottom:1px solid #26324d}
    main{max-width:1100px;margin:0 auto;padding:20px;display:grid;gap:20px}
    .card{background:#121a34;border:1px solid #26324d;border-radius:var(--radius);padding:16px}
    h1{font-size:clamp(1.2rem,2.5vw,1.6rem);margin:0 0 6px}
    h2{font-size:1.05rem;margin:0 0 10px}
    small,.muted{color:#9fb0cf}
    .row{display:flex;gap:var(--gap);flex-wrap:wrap;align-items:flex-end}
    .row > *{flex:1 1 220px}
    input,select,button{width:100%;box-sizing:border-box;border-radius:10px;border:1px solid #39507d;background:#0b142c;color:#e7ecf5;padding:10px 12px}
    input[type=number]{appearance:textfield}
    button{cursor:pointer;background:#2a6df3;border-color:#2a6df3}
    button.secondary{background:#182445;border-color:#39507d}
    button:disabled{opacity:.6;cursor:not-allowed}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid #26324d;text-align:left}
    tr:hover td{background:#0f1a34}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #39507d;background:#0b142c;color:#cdd9f0;font-size:.85rem}
    .grid{display:grid;gap:var(--gap)}
    .two{grid-template-columns:repeat(2,minmax(0,1fr))}
    .three{grid-template-columns:repeat(3,minmax(0,1fr))}
    .result{font-size:1.25rem}
    .ok{color:#86efac}.warn{color:#fbbf24}.bad{color:#f87171}
    footer{opacity:.85;padding:10px 16px;text-align:center}
    .inline-help{font-size:.9rem;color:#9fb0cf}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid #39507d;border-radius:999px;background:#0b142c}
    .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .right{text-align:right}
    /* SVG rajz keret */
    .svg-wrap{background:#0b142c;border:1px dashed #39507d;border-radius:10px;padding:10px}
  </style>
</head>
<body>
  <header>
    <h1>Kábelárok kalkulátor – MSZ 13207:2020</h1>
    <small>Másold be a kábeleket, válaszd ki a fektetést, és megkapod a szabvány szerinti minimális méreteket.</small>
  </header>

  <main>
    <!-- BEÁLLÍTÁSOK -->
    <section class="card">
      <h2>1) Általános beállítások</h2>
      <div class="row">
        <div>
          <label>Terület típusa
            <select id="terrain">
              <option value="regulated">Szabályozott terep (jellemzően beépített) – 0,6…0,8 m fektetési mélység</option>
              <option value="unregulated">Szabályozatlan terep (pl. külterület) – min. 1,0 m fektetési mélység</option>
            </select>
          </label>
        </div>
        <div>
          <label>Választott fektetési mélység (m) 
            <input id="depth" type="number" step="0.1" min="0.3" value="0.7">
          </label>
          <div class="inline-help">Ajánlott: 0,7 m (szabvány szerinti kiinduló érték).</div>
        </div>
        <div>
          <label>Elrendezés a kábelárokban
            <select id="layout">
              <option value="single">Egy síkban (sorba rendezve)</option>
              <option value="trefoil">Három egyerű kábel érintő háromszögben (trefoil) – csoportonként 3 db</option>
              <option value="multirow">Több réteg (egymás felett) – min. 0,2 m ágyazóréteg a rétegek között</option>
            </select>
          </label>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Oldaltávolság a kábel és az árok fala között (m)
            <input id="sideClear" type="number" step="0.01" value="0.10" min="0.10">
          </label>
          <div class="inline-help">Min. 0,10 m mindkét oldalon.</div>
        </div>
        <div>
          <label>Kábelek közötti távolság (m)
            <input id="spacing" type="number" step="0.01" value="0.07" min="0.05">
          </label>
          <div class="inline-help">Alapértelmezés: 0,07 m. Védőcsövek közt min. 0,05 m (állítható).</div>
        </div>
        <div>
          <label>Ágyazóréteg alul/felül (m)
            <input id="bedding" type="number" step="0.01" value="0.05" min="0.00">
          </label>
          <div class="inline-help">I–II. talajosztályban homokágy nem kötelező; egyébként alul és felül min. 0,05 m.</div>
        </div>
      </div>
    </section>

    <!-- KÁBEL LISTA -->
    <section class="card">
      <h2>2) Kábelek felvétele</h2>
      <div class="row">
        <div>
          <label>Kábel külső átmérő (mm)
            <input id="diameter" type="number" step="1" min="1" value="40">
          </label>
        </div>
        <div>
          <label>Darabszám
            <input id="count" type="number" step="1" min="1" value="3">
          </label>
        </div>
        <div>
          <label>Védőcsőben?
            <select id="inDuct">
              <option value="no">Nem</option>
              <option value="yes">Igen (védőcső)</option>
            </select>
          </label>
        </div>
        <div>
          <label>Megjegyzés (opcionális)
            <input id="note" type="text" placeholder="pl. 3×1C 240 mm² trefoil csoport">
          </label>
        </div>
        <div>
          <button id="addCable">Felvétel</button>
        </div>
      </div>

      <table id="cableTable">
        <thead>
          <tr>
            <th>#</th><th>Átmérő (mm)</th><th>Darab</th><th>Védőcső</th><th>Megjegyzés</th><th></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="flex">
        <span class="chip">Min. árokszélesség: <span class="pill">400 mm</span></span>
        <span class="chip">Min. kábelek közti távolság: <span class="pill">70 mm</span> (<span class="pill">50 mm</span> védőcsövek közt)</span>
        <span class="chip">Oldaltávolság: <span class="pill">100 mm</span> / oldal</span>
      </div>
    </section>

    <!-- EREDMÉNY + RAJZ + EXPORT -->
    <section class="card">
      <h2>3) Eredmények & sematikus rajz</h2>
      <div class="grid two">
        <div class="result">Számított <strong>kábelárok-szélesség</strong>: <span id="widthOut" class="pill">–</span></div>
        <div class="result">Becsült <strong>kábelárok-mélység</strong>: <span id="depthOut" class="pill">–</span></div>
      </div>
      <div class="grid">
        <div><span class="pill">Jelzőszalag: min. 0,3 m-rel a legfelső kábel felett</span> <span id="tapeLevel" class="muted"></span></div>
        <div class="inline-help">A mélység számítás figyelembe veszi az alul/felül ágyazóréteget és a kiválasztott fektetési mélységet.</div>
      </div>

      <div class="svg-wrap" style="margin-top:10px">
        <svg id="schematic" width="100%" height="360" viewBox="0 0 800 360" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Kábelárok sematikus rajz">
          <!-- Dinamikus rajz ide kerül -->
        </svg>
      </div>

      <div class="row" style="margin-top:10px">
        <div><button class="secondary" id="exportBtn">Eredmény letöltése (TXT)</button></div>
        <div><button class="secondary" id="exportDxfBtn">Rajz exportálása (DXF)</button></div>
      </div>
    </section>

    <section class="card">
      <h2>Hivatkozás</h2>
      <small>MSZ 13207:2020 – Kábelek és vezetékek létesítése (a geometriai minimumokra építve: ≥0,07 m kábelköz, ≥0,10 m oldaltávolság, min. 0,40 m árokszélesség; trefoil és többrétegű fektetés megengedett; jelzőszalag ≥0,3 m-rel feljebb; tipikus fektetési mélység szabályozott terepen 0,6–0,8 m).</small>
    </section>
  </main>

  <footer class="muted">Készült a SolServices részére • DXF-exporttal</footer>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const state = { items: [] };

    const tableBody = $("#cableTable tbody");
    const terrain = $("#terrain");
    const depthInput = $("#depth");
    const layoutSel = $("#layout");
    const sideClear = $("#sideClear");
    const spacing = $("#spacing");
    const bedding = $("#bedding");
    const widthOut = $("#widthOut");
    const depthOut = $("#depthOut");
    const tapeLevel = $("#tapeLevel");
    const svg = $("#schematic");

    // Helpers
    function mm(v){ return Number(v) || 0 }
    function round(v,dec=2){ const p=Math.pow(10,dec); return Math.round(v*p)/p }
    function toMeters(mmVal){ return (mmVal/1000) }
    function safeParse(v,def=0){ const n=Number(v); return isFinite(n)?n:def }

    function renderTable(){
      tableBody.innerHTML = "";
      state.items.forEach((it,idx)=>{
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${idx+1}</td>
          <td>${it.diam} mm</td>
          <td>${it.count}</td>
          <td>${it.inDuct ? "Igen" : "Nem"}</td>
          <td>${it.note||""}</td>
          <td class="right"><button class="secondary" data-remove="${idx}">Törlés</button></td>
        `;
        tableBody.appendChild(tr);
      });
      tableBody.querySelectorAll("button[data-remove]").forEach(btn=>{
        btn.addEventListener("click", e=>{
          const i = Number(e.target.getAttribute("data-remove"));
          state.items.splice(i,1);
          renderTable();
          compute();
        })
      })
    }

    function addCable(){
      const diam = mm($("#diameter").value);
      const count = Math.max(1, Math.floor(safeParse($("#count").value,1)));
      const inDuct = $("#inDuct").value === "yes";
      const note = $("#note").value.trim();

      if(diam<=0){ alert("Adj meg érvényes kábel-átmérőt (mm)!"); return; }
      state.items.push({diam, count, inDuct, note});
      $("#note").value="";
      renderTable();
      compute();
    }
    $("#addCable").addEventListener("click", addCable);

    // Elrendezés kiszámítása + geometria
    function compute(){
      // paraméterek (m)
      const side = Math.max(0.10, safeParse(sideClear.value, 0.10)); // >=0.10 m
      const baseSpacing = Math.max(0.05, safeParse(spacing.value, 0.07)); // >=0.07 m; ducts >=0.05 m
      const bed = Math.max(0, safeParse(bedding.value, 0.05));
      const depthSel = Math.max(0.3, safeParse(depthInput.value, 0.7)); // >=0.3 m
      const layout = layoutSel.value;

      // Terep szerinti min. mélység
      const terr = terrain.value;
      const minDepth = terr === "regulated" ? 0.6 : 1.0;
      const usedDepth = Math.max(depthSel, minDepth);

      // Elemlista (mm -> m)
      let elements = [];
      state.items.forEach(it=>{
        const effDiam = it.inDuct ? (it.diam + 10) : it.diam; // cső becslés: +10 mm
        for(let i=0;i<it.count;i++){ elements.push({d_mm: effDiam, inDuct: it.inDuct}); }
      });

      // Sorokba rendezés
      let rows = [];
      const sToM = (arr)=> arr.reduce((sum,e)=>sum + toMeters(e.d_mm),0);
      if(layout==="trefoil"){
        // 3-as csoportok (érintve), csoportok közt baseSpacing
        elements.sort((a,b)=>b.d_mm-a.d_mm);
        let groups=[];
        for(let i=0;i<elements.length;i+=3){
          const g = elements.slice(i,i+3);
          if(g.length===0) break;
          const maxd = Math.max(...g.map(x=>x.d_mm));
          groups.push({d_mm:maxd});
        }
        const width = (groups.length? groups.reduce((s,g)=>s+toMeters(g.d_mm),0) + (groups.length-1)*baseSpacing : 0);
        rows = [{type:"trefoil", width_m: width, items: groups.map(g=>({d_m: toMeters(g.d_mm)}))}];
      } else if(layout==="multirow"){
        elements.sort((a,b)=>b.d_mm-a.d_mm);
        const half = Math.ceil(elements.length/2);
        const rowA = elements.slice(0, half);
        const rowB = elements.slice(half);
        const wA = (rowA.length? sToM(rowA) + (rowA.length-1)*baseSpacing : 0);
        const wB = (rowB.length? sToM(rowB) + (rowB.length-1)*baseSpacing : 0);
        rows = [
          {type:"line", width_m:wA, items: rowA.map(e=>({d_m: toMeters(e.d_mm)}))},
          {type:"line", width_m:wB, items: rowB.map(e=>({d_m: toMeters(e.d_mm)}))}
        ];
      } else { // single
        const w = (elements.length? sToM(elements) + (elements.length-1)*baseSpacing : 0);
        rows = [{type:"line", width_m: w, items: elements.map(e=>({d_m: toMeters(e.d_mm)}))}];
      }

      // Belső szélesség (max sor szélesség) + 2*oldaltáv, min 0.4 m
      const innerWidth = rows.reduce((m,r)=>Math.max(m, r.width_m), 0);
      const trenchWidth = Math.max(0.4, innerWidth + 2*side);

      // Mélység (becslés): választott fektetési mélység (kábel teteje) + felső ágyazóréteg
      const topOfCable = usedDepth;
      const trenchDepth = topOfCable + bed;
      const tape = topOfCable + 0.30;

      // Kiírás
      widthOut.textContent = `${round(trenchWidth, 3)} m (min)`;
      depthOut.textContent = `${round(trenchDepth, 3)} m (becsült árok-mélység)`;
      tapeLevel.textContent = `– javasolt elhelyezési szint: ${round(tape,2)} m a terepszint alatt`;
      widthOut.className = "pill " + (trenchWidth >= 0.4 && side >= 0.10 ? "ok":"bad");
      if(terr==="regulated" && (usedDepth<0.6 || usedDepth>0.8)){
        depthOut.className = "pill warn";
      }else if(terr==="unregulated" && usedDepth<1.0){
        depthOut.className = "pill bad";
      }else{
        depthOut.className = "pill ok";
      }

      // Rajz frissítése
      drawSVG({rows, trenchWidth, trenchDepth, side, baseSpacing, bed, usedDepth, topOfCable});
      // DXF export adatok elmentése
      state._geom = {rows, trenchWidth, trenchDepth, side, baseSpacing, bed, usedDepth, topOfCable};
    }

    // SVG rajz (egyszerű keresztmetszet)
    function drawSVG(g){
      const Wpx = 800, Hpx = 360;
      svg.setAttribute("viewBox", `0 0 ${Wpx} ${Hpx}`);
      while(svg.firstChild) svg.removeChild(svg.firstChild);

      // skálák (m -> px): szélesség 80% a keretben
      const margin = 40;
      const pxPerM_X = (Wpx - 2*margin) / Math.max(0.8, g.trenchWidth);
      const pxPerM_Y = (Hpx - 2*margin) / Math.max(0.8, g.trenchDepth);

      const ox = (Wpx - g.trenchWidth * pxPerM_X)/2; // középre
      const oy = margin;

      // árok doboz
      const trenchWpx = g.trenchWidth * pxPerM_X;
      const trenchHpx = g.trenchDepth * pxPerM_Y;
      const rect = rectEl(ox, oy, trenchWpx, trenchHpx, "#334a7a", "#99b3ff");
      svg.appendChild(rect);

      // alj/homokágy jelölés
      if(g.bed>0){
        const bedH = g.bed*pxPerM_Y;
        const bedRect = rectEl(ox, oy, trenchWpx, bedH, "#1b2a4d", "#5fa8ff99");
        svg.appendChild(bedRect);
      }

      // kábelek: minden sorhoz rajzolj köröket a fenék felett (bed + 0.02 m vizuális ráhagyás)
      const baseY_m = g.bed + 0.02; // vizuális
      let rowYs = [];
      if(g.rows.length===1){
        rowYs = [baseY_m];
      }else{
        // több réteg: 0.20 m rétegek között
        rowYs = [baseY_m, baseY_m + 0.20];
      }
      // trefoilban egy sor: a körök egymáshoz képest háromszögben
      const centerX0 = (Wpx/2) - ( (g.trenchWidth/2 - g.side) * pxPerM_X );

      // vízszintes pozícionálás: bal oldali oldaltáv
      const startX_m = g.side;
      const startX_px = ox + startX_m * pxPerM_X;

      g.rows.forEach((row, rIdx)=>{
        let x_m = startX_m;
        if(row.type==="trefoil"){
          // csoportok középre igazítva
          const totalRowW = row.width_m;
          let x0 = (g.trenchWidth - totalRowW)/2;
          let cx = ox + x0*pxPerM_X;
          row.items.forEach((it, i)=>{
            const d = it.d_m;
            const rpx = (d/2)*pxPerM_X;
            // trefoil három pontja (egyszerű szabályos háromszög a körök középpontjaival, érintő elrendezés)
            const a = d; // középponttávolság ~ d
            const p1 = {x: cx + rpx, y: oy + (baseY_m + rIdx*0.20)*pxPerM_Y + (d)*pxPerM_Y};
            const p2 = {x: cx + rpx + a*pxPerM_X/2, y: oy + (baseY_m + rIdx*0.20)*pxPerM_Y + rpx};
            const p3 = {x: cx + rpx + a*pxPerM_X, y: oy + (baseY_m + rIdx*0.20)*pxPerM_Y + (d)*pxPerM_Y};
            [p1,p2,p3].forEach(p=>{
              svg.appendChild(circleEl(p.x, p.y, rpx, "#2a5fff", "#2a5fff55"));
            });
            cx += d*pxPerM_X + g.baseSpacing*pxPerM_X;
          });
        } else {
          // egysoros: jobbra haladva
          let rowW = row.items.length? row.items.reduce((s,it)=>s+it.d_m,0) + (row.items.length-1)*g.baseSpacing : 0;
          let x0 = (g.trenchWidth - rowW)/2;
          let cx = ox + x0*pxPerM_X;
          const cy = oy + (rowYs[rIdx])*pxPerM_Y + (row.items.length? (Math.max(...row.items.map(i=>i.d_m))/2)*pxPerM_Y : 0);
          row.items.forEach((it, i)=>{
            const rpx = (it.d_m/2)*pxPerM_X;
            svg.appendChild(circleEl(cx + rpx, cy, rpx, "#2a5fff", "#2a5fff55"));
            cx += it.d_m*pxPerM_X + (i<row.items.length-1 ? g.baseSpacing*pxPerM_X : 0);
          });
        }
      });

      // méretvonalak (szélesség és mélység)
      // szélesség
      const wY = oy + trenchHpx + 30;
      svg.appendChild(dimLine(ox, wY, ox+trenchWpx, wY, `${round(g.trenchWidth,2)} m`));
      // mélység
      const dX = ox - 30;
      svg.appendChild(dimVLine(dX, oy, oy+trenchHpx, `${round(g.trenchDepth,2)} m`));
      // oldaltáv jelzés
      svg.appendChild(dimLine(ox, oy-20, ox + g.side*pxPerM_X, oy-20, `${round(g.side,2)} m (oldal)`));
      svg.appendChild(dimLine(ox+trenchWpx - g.side*pxPerM_X, oy-20, ox+trenchWpx, oy-20, `${round(g.side,2)} m (oldal)`));
    }

    // SVG helper elemek
    function rectEl(x,y,w,h,stroke="#555",fill="#0000"){
      const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
      r.setAttribute("x", x); r.setAttribute("y", y); r.setAttribute("width", w); r.setAttribute("height", h);
      r.setAttribute("fill", fill); r.setAttribute("stroke", stroke); r.setAttribute("stroke-width", 2);
      return r;
    }
    function circleEl(cx,cy,r,stroke,fill){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", r);
      c.setAttribute("fill", fill); c.setAttribute("stroke", stroke); c.setAttribute("stroke-width", 2);
      return c;
    }
    function dimLine(x1,y1,x2,y2,label){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      const l = document.createElementNS("http://www.w3.org/2000/svg","line");
      l.setAttribute("x1",x1); l.setAttribute("y1",y1); l.setAttribute("x2",x2); l.setAttribute("y2",y2);
      l.setAttribute("stroke","#9fb0cf"); l.setAttribute("stroke-width","2");
      const a1 = arrow(x1,y1,true), a2 = arrow(x2,y2,false);
      g.appendChild(l); g.appendChild(a1); g.appendChild(a2);
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.textContent = label; t.setAttribute("x",(x1+x2)/2); t.setAttribute("y", y2-6);
      t.setAttribute("fill","#cfe1ff"); t.setAttribute("font-size","12"); t.setAttribute("text-anchor","middle");
      g.appendChild(t); return g;
    }
    function dimVLine(x1,y1,y2,label){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      const l = document.createElementNS("http://www.w3.org/2000/svg","line");
      l.setAttribute("x1",x1); l.setAttribute("y1",y1); l.setAttribute("x2",x1); l.setAttribute("y2",y2);
      l.setAttribute("stroke","#9fb0cf"); l.setAttribute("stroke-width","2");
      const a1 = varrow(x1,y1,true), a2 = varrow(x1,y2,false);
      g.appendChild(l); g.appendChild(a1); g.appendChild(a2);
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.textContent = label; t.setAttribute("x",x1-6); t.setAttribute("y",(y1+y2)/2);
      t.setAttribute("fill","#cfe1ff"); t.setAttribute("font-size","12"); t.setAttribute("text-anchor","end");
      g.appendChild(t); return g;
    }
    function arrow(x,y,left){
      const p = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      const s = left? `${x+8},${y-6} ${x},${y} ${x+8},${y+6}` : `${x-8},${y-6} ${x},${y} ${x-8},${y+6}`;
      p.setAttribute("points", s); p.setAttribute("fill","none"); p.setAttribute("stroke","#9fb0cf"); p.setAttribute("stroke-width","2"); return p;
    }
    function varrow(x,y,up){
      const p = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      const s = up? `${x-6},${y+8} ${x},${y} ${x+6},${y+8}` : `${x-6},${y-8} ${x},${y} ${x+6},${y-8}`;
      p.setAttribute("points", s); p.setAttribute("fill","none"); p.setAttribute("stroke","#9fb0cf"); p.setAttribute("stroke-width","2"); return p;
    }

    // TXT export (változatlanul)
    $("#exportBtn").addEventListener("click", ()=>{
      const lines = [];
      lines.push("Kábelárok kalkuláció – MSZ 13207:2020");
      lines.push("");
      lines.push(`Terep: ${terrain.value==="regulated"?"Szabályozott":"Szabályozatlan"}`);
      lines.push(`Választott fektetési mélység (kábel teteje): ${round(Math.max(0.3, Number(depthInput.value)||0.7),2)} m`);
      lines.push(`Elrendezés: ${layoutSel.options[layoutSel.selectedIndex].text}`);
      lines.push(`Oldaltávolság: ≥ ${round(Math.max(0.10, Number(sideClear.value)||0.10),2)} m (oldalanként)`);
      lines.push(`Kábel/köteg közti távolság: ≥ ${round(Math.max(0.05, Number(spacing.value)||0.07),2)} m`);
      lines.push(`Ágyazóréteg (alul/felül): ${round(Math.max(0, Number(bedding.value)||0.05),2)} m`);
      lines.push("");
      state.items.forEach((it,i)=>{
        lines.push(`#${i+1} – d=${it.diam} mm , védőcső: ${it.inDuct?"igen":"nem"}${it.note?(" , megjegyzés: "+it.note):""}`);
      });
      lines.push("");
      lines.push(`Számított árokszélesség (min): ${$("#widthOut").textContent}`);
      lines.push(`Becsült árok-mélység: ${$("#depthOut").textContent}`);
      lines.push(`Jelzőszalag szint (min): ${$("#tapeLevel").textContent.replace("– ","")}`);
      const blob = new Blob([lines.join("\n")], {type:"text/plain"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "kabelarok_kalkulacio.txt";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    });

    // DXF export (R12, méter egységek)
    function dxfHeader(){
      return [
        "0","SECTION","2","HEADER",
        "9","$INSUNITS","70","6", // meters
        "0","ENDSEC",
        "0","SECTION","2","ENTITIES"
      ].join("\n");
    }
    function dxfFooter(){ return "0\nENDSEC\n0\nEOF\n"; }
    function dxfLine(x1,y1,x2,y2,layer="0"){
      return ["0","LINE","8",layer,"10",x1,"20",y1,"30",0,"11",x2,"21",y2,"31",0].join("\n");
    }
    function dxfCircle(cx,cy,r,layer="0"){
      return ["0","CIRCLE","8",layer,"10",cx,"20",cy,"30",0,"40",r].join("\n");
    }
    function dxfText(x,y,h,txt,layer="0"){
      return ["0","TEXT","8",layer,"10",x,"20",y,"30",0,"40",h,"1",txt].join("\n");
    }
    function exportDXF(){
      const g = state._geom;
      if(!g){ alert("Előbb adj meg kábeleket és számolj!"); return; }

      // DXF-ben közvetlenül méter egységben dolgozunk. Felvesszük a bal-alsó sarok origót (0,0).
      // Árok téglalap (0,0) – (width, depth)
      let ents = [];
      ents.push(dxfHeader());
      const W = g.trenchWidth, D = g.trenchDepth;

      // Árok kontúr (téglalap)
      ents.push(dxfLine(0,0, W,0, "TRENCH"));
      ents.push(dxfLine(W,0, W,D, "TRENCH"));
      ents.push(dxfLine(W,D, 0,D, "TRENCH"));
      ents.push(dxfLine(0,D, 0,0, "TRENCH"));

      // Alsó ágyazóréteg jelzés
      if(g.bed>0){
        ents.push(dxfLine(0,g.bed, W,g.bed, "BED"));
      }

      // Kábelek: sorok elhelyezése (középre igazítva)
      let baseY = g.bed + 0.02;
      let rowYs = (g.rows.length===1) ? [baseY] : [baseY, baseY + 0.20];

      g.rows.forEach((row, rIdx)=>{
        if(row.type==="trefoil"){
          // csoportok egymás mellett
          const totalRowW = row.width_m;
          let x = (W - totalRowW)/2;
          row.items.forEach((it)=>{
            const d = it.d_m, r = d/2;
            // három kör (érintő háromszög)
            const a = d;
            const p1 = {x: x + r, y: rowYs[rIdx] + d};
            const p2 = {x: x + r + a/2, y: rowYs[rIdx] + r};
            const p3 = {x: x + r + a,   y: rowYs[rIdx] + d};
            [p1,p2,p3].forEach(p=> ents.push(dxfCircle(p.x, p.y, r, "CABLE")));
            x += d + g.baseSpacing;
          });
        } else {
          // egysoros sor
          const rowW = row.items.length? row.items.reduce((s,it)=>s+it.d_m,0) + (row.items.length-1)*g.baseSpacing : 0;
          let x = (W - rowW)/2;
          const maxd = row.items.length? Math.max(...row.items.map(i=>i.d_m)) : 0;
          const cy = rowYs[rIdx] + maxd/2;
          row.items.forEach((it, i)=>{
            ents.push(dxfCircle(x + it.d_m/2, cy, it.d_m/2, "CABLE"));
            x += it.d_m + (i<row.items.length-1 ? g.baseSpacing : 0);
          });
        }
      });

      // Méretvonalak (egyszerű)
      // szélesség (alul)
      ents.push(dxfLine(0,-0.10, W,-0.10, "DIM"));
      ents.push(dxfLine(0,-0.12, 0,-0.08, "DIM"));
      ents.push(dxfLine(W,-0.12, W,-0.08, "DIM"));
      ents.push(dxfText(W/2, -0.16, 0.05, `${round(W,2)} m`, "DIM"));
      // mélység (bal oldalt)
      ents.push(dxfLine(-0.10,0, -0.10,D, "DIM"));
      ents.push(dxfLine(-0.12,0, -0.08,0, "DIM"));
      ents.push(dxfLine(-0.12,D, -0.08,D, "DIM"));
      ents.push(dxfText(-0.14, D/2, 0.05, `${round(D,2)} m`, "DIM"));

      // oldaltáv jelzés
      ents.push(dxfLine(0,-0.30, g.side, -0.30, "DIM"));
      ents.push(dxfText(g.side/2, -0.34, 0.04, `${round(g.side,2)} m (oldal)`, "DIM"));
      ents.push(dxfLine(W-g.side, -0.30, W, -0.30, "DIM"));
      ents.push(dxfText(W-g.side/2, -0.34, 0.04, `${round(g.side,2)} m (oldal)`, "DIM"));

      // jelzőszalag szint jelzés
      const tapeY = g.topOfCable + 0.30;
      ents.push(dxfLine(-0.20, tapeY, W+0.20, tapeY, "TAPE"));
      ents.push(dxfText(W+0.22, tapeY, 0.04, "jelzőszalag +0.30 m", "TAPE"));

      ents.push(dxfFooter());
      const blob = new Blob([ents.join("\n")], {type:"application/dxf"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "kabelarok_rajz.dxf";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }
    $("#exportDxfBtn").addEventListener("click", exportDXF);

    // Reaktív frissítés
    [terrain, depthInput, layoutSel, sideClear, spacing, bedding].forEach(el=>{
      el.addEventListener("input", compute);
      el.addEventListener("change", compute);
    });

    // Init
    renderTable(); compute();
  </script>
</body>
</html>
